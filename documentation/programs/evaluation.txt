Types determining evaluation of modeled language

Evaluating binary operations down to values (function)
bopeval: boptype -> value -> value -> value

Evaluating expressions to values (relation)
eeval: nvmem -> vmem -> exp -> readobs -> value -> Prop

Executing commands, accumulating write data
(continuous) (1.2):
cceval_w: context -> obseq -> context -> the_write_stuff -> Prop

Executing commands, accumulating write data
(intermittent) (1.3): 
iceval: iconf -> obseq -> iconf -> the_write_stuff -> Prop

Variables read from when evaluating an expression:
rd: exp -> warvars -> prop

checking WAR soundess of evaluating an instruction (2.1):
warcheck: nvmem -> warvars -> warvars -> instruction -> warvars -> warvars -> P

checking WAR soundess of executing a command (2.1):
WARok:  nvmem -> warvars -> warvars -> command -> P

(3.1)
Where
O1 is a sequence of read observation lists,
where each continguous read observation list is separated from those adjacent to it by a reboot,
and O2 is a read observation list,
prefix_seq determines if each ro list in O1 is a valid
prefix of O2
prefix_seq: obseq -> readobs -> Prop

(* Where
O1 is a sequence of ((read observation list sequences), where
each continguous read observation list is separated from those adjacent to it
by a reboot), where each sequence is separated from those adjacent to it by a checkpoint.
ie, each read observation list in a given read observation sequence
occurs within the same checkpointed region as all the other read observation lists in that sequence,
O2 is a read observation list,
prefix_frag determines if each ro list in O1 is a prefix of some FRAGMENT of O2
(where the fragments are separated by the positioning of the checkpoints in O1)
 *)
prefix_fragment: obseq -> readobs -> Prop
